extends layout

block title
	- string title = "Documentation";

block navigation
	ul
		li.separator
			a(href="api/") API Reference
		li
			a(href="#installation") Installation
		li
			a(href="#first-steps") First steps
		li
			a(href="#http") HTTP
			ul
				li
					a(href="#http-server-config") Server configuration
				li
					a(href="#http-routing") Routing
				li
					a(href="#http-templates") Templates
				li
					a(href="#http-error-pages") Error pages
				li
					a(href="#http-authentication") Authentication
				li
					a(href="#http-sessions") Sessions
				li
					a(href="#http-client-requests") Client requests
		li
			a(href="#db-support") Database support
			ul
				li
					a(href="#mongo") MongoDB
				li
					a(href="#redis") Redis
		li
			a(href="#raw-tcp") Raw TCP
			ul
				li
					a(href="#tcp-server") Server
				li
					a(href="#tcp-client") Client
		li.separator
			a(href="#advanced") Advanced topics
			ul
				li
					a(href="#dub-publishing") Publishing on the DUB registry
				li
					a(href="#custom-main") Custom main function
				li
					a(href="#privilege-lowering") Privilege lowering
		li.separator
			a(href="templates/diet") Diet Reference
		li
			a.extern(href="http://dlang.org/phobos/index.html", target="_blank") D Library Reference

block body
	section
		h2#installation Installation
		
		p On Debian and Debian based systems such as Ubuntu, you can install an APT repository that will allow you to stay up-to-date including all dependencies automatically. See the
			a(href="https://github.com/rejectedsoftware/vibe.d#installation-on-linux-debianubuntu-using-apt") github page
			| for instructions.

		p On all other systems, the installation currently is a simple manual process. You just have to extract the downloaded archive and make the vibe script callable from anywhere.
		
		p On Windows, add the 'bin' directory to the PATH by going to Advanced System Settings/Advanced/Environment Variables and entering the path into either the user PATH variable or the system wide version.
		
		p For *NIXes, there are setup scripts that create the symlink and add an unprivileged 'www-vibe' user to allow for
			a(href="#privilege-lowering") privilege lowering
			| on server systems. Depending on the operating system, run the appropriate setup script from directory where the files have been extracted:
			code
				pre $ ./setup-linux.sh
					| or
					|$ ./setup-mac.sh
					| or
					|$ ./setup-freebsd.sh
				
		p On non-Windows systems you may need to install some additional dependencies. See the
			a(href="https://github.com/rejectedsoftware/vibe.d#vibed") github page
			| for more information.
		
		p After the installation, you can run any vibe.d application by typing 'vibe' from inside the application's root directory. You can try this by starting one of the exammples:
			code
				pre $ cd examples/http_server
					|$ vibe
					|Checking dependencies in 'C:\\Users\\sludwig\\Develop\\vibe.d\\examples\\http_server'
					|Listening on 0.0.0.0 port 8080 succeeded
					|Listening on :: port 8080 succeeded
					|Running event loop...

	section
		h2#first-steps First steps

		p The easiest way to get started is to run the following command from your projects directory:

		code
			pre
				|$ cd /path/to/my/projects
				|$ vibe init &lt;project-name&gt;

		p This will create a new directory with the given name and creates the basic directory structure that is recommended for a vibe.d project. You can then go ahead and edit the <code>source/app.d</code> file. You should also edit the <code>package.json</code> file if you want to publish your project.

		p The recommended structure for a project is about as follows:

		code
			pre appname/
				|	package.json
				|	source/
				|		app.d
				|	public/
				|		images/
				|		styles/
				|			style.css
				|	views/
				|		layout.dt
				|		index.dt
			.caption Example structure of a web application project

		p The 'app.d' file could look similar to this one:
		
		code
			pre.code.prettyprint.lang-d import vibe.d;
				|
				|void index(HttpServerRequest req, HttpServerResponse res)
				|{
				|	res.renderCompat!("index.dt", HttpServerRequest, "req")(req);
				|
				|	// not recommended alternative, may cause memory corruption due to a DMD bug
				|	//res.render!("index.dt", req);
				|}
				|
				|static this()
				|{
				|	auto router = new UrlRouter;
				|	router.get("/", &index);
				|
				|	auto settings = new HttpServerSettings;
				|	settings.port = 8080;
				|
				|	listenHttp(settings, router);
				|}
			.caption Simple app.d file with minimal routing

		p The 'views' sub folder is automatically searched for templates instantiated with <a href="api/vibe.http.server/render"><code class="prettyprint">render()</code></a>. The two templates in the example structure might look like this:

		code
			pre !\!! 5
				|html
				|	head
				|		title Example page
				|	body
				|		block body
			.caption Example layout.dt

		code
			pre extends layout
				|
				|block body
				|	h1 Example page - Home
				|	p Hello, World!
			.caption Example index.dt

		p This structure makes use of the blocks/extensions feature of the <a href="#http-templates">template</a> parser. For more advanced template features see the
			a(href="templates/diet")Diet template documentation
			|.
			
		p Finally, you can add a package.json file to let the vibe.d package manager automatically download and compile extension libraries. This file will also provide the description that is needed to later put your own library into the
			a(href="http://registry.vibed.org/") public extension registry
			|.
		
		code
			pre {
				|	"name": "appname",
				|	"description": "My fabulous new app",
				|	"copyright": "Copyright (C) 2000 Me. All rights reserved.",
				|	"homepage": "http://appname.org",
				|	"authors": [
				|		"Hans Wurst"
				|	],
				|	"dependencies": {
				|	}
				|}
			.caption Example package.json
			
		p Once you have the project in place, simply run vibe from the project's root directory and it will get all dependencies, compile the application, and run it:
			code
				pre $ cd path/to/project
					|$ vibe
					|Checking dependencies in 'path/to/project'
					|Listening on 0.0.0.0 port 8080 succeeded
					|Listening on :: port 8080 succeeded
					|Running event loop...

	section
		h2#http HTTP

		section
			h3#http-server-config Server configuration

			p The HTTP server supports a number of configuration options to customize its behavior. By default, the server will listen on all local network adapters on port 80 and will perform complete request parsing. The following list gives an overview of the most common settings:
				dl.feat
					dt port
					dd The port on which the HTTP server shall listen
					
					dt bindAddresses
					dd A list of all interfaces on which the server shall listen. IPv4 and IPv6 addresses, as well as domain names are supported.

					dt options
					dd Controls optional features of the web server. Certain options can be disabled to increase speed or to decrease memory usage. By default, the following options are enabled: 	ParseURL, ParseQueryString, ParseFormBody, ParseJsonBody, ParseMultiPartBody, ParseCookies. Enabled options are ORed together.

					dt errorPageHandler
					dd Provides a way to customize error pages. For example:
						code
							pre.code.prettyprint.lang-d void errorPage(HttpServerRequest req,
								|               HttpServerResponse res,
								|               HttpServerErrorInfo error)
								|{
								|	//res.render!("error.dt", req, error); // still affected by a compiler bug
								|	res.renderCompat!("error.dt",
								|		HttpServerRequest, "req",
								|		HttpServerErrorInfo, "error")
								|		(req, error);
								|}
								|
								|static this()
								|{
								|	auto settings = new HttpServerSettings;
								|	settings.errorPageHandler = toDelegate(&errorPage);
								|	// ...
								|}
						| Inside of the error.dt template, the variables req, code and msg are available in this example.

					dt sslCertFile, sslKeyFile
					dd If OpenSSL compatible key and certificate files are given, the server will operate as an HTTPS server. You should probably also set the port to 443 in this case.

		section
			h3#http-routing Routing

			p The
				code
					a(href="/api/http.router/UrlRouter") UrlRouter
				| class provides a convenient way to let different functions handle different URLs. It supports static path matching, variable placeholders and wild-cards. Any matched variable will be available as an entry in the HttpRequest.params dictionary.
			p In addition to the path, the HTTP method is also used for matching requests. Each HTTP method has a corresponding method in the
				span.dclass UrlRouter
				| class (e.g. .get() or .post()). The following example will route all GET requests matching the path scheme "/users/*" to the
				span.dfunction userinfo
				| handler and serve all other GET requests using the files in the public folder.

			code
				pre.code.prettyprint.lang-d import vibe.d;
					|
					|void userInfo(HttpServerRequest req, HttpServerResponse res)
					|{
					|	auto username = req.params["user"];
					|	render!("userinfo.jd", username)(res);
					|}
					|
					|void addUser(HttpServerRequest req, HttpServerResponse res)
					|{
					|	res.redirect("/users/"~req.post["user"]);
					|}
					|
					|static this()
					|{
					|	auto router = new UrlRouter;
					|	router.get("/users/:user", &userInfo);
					|	router.post("/adduser", &addUser);
					|	router.get("*", serveStaticFiles("./public/"));
					|
					|	// To reduce code redundancy, you can also
					|	// use method chaining:
					|	router
					|		.get("/users/:user", &userInfo)
					|		.post("/adduser", &addUser);
					|		.get("*", serveStaticFiles("./public/"));
					|
					|	listenHttp(new HttpServerSettings, router);
					|}
				.caption Example: GET/POST routing and static file serving

		section
			h3#http-templates Diet templates

			p Vibe supports HTML templates with a syntax mostly compatible to
				a.extern(href="http://jade-lang.com/", target="_blank") jade
				| templates. They provide a concise way to dynamically generate the HTML code of the final web pages. D expressions and statements can be embedded and the full vibe API is available within templates.

			p Templates should reside somewhere inside the 'views' folder of a project. They are then rendered using the
				span.dfunction render
				| function, which takes the template file name as the first template argument, followed by a list of variables that should be available to the template. Finally, it takes a
				span.dclass HttpServerResponse
				| to render into.

			p The following example shows a number of features of the template parser. A full reference of the template syntax is found on the
				a(href="templates/diet") Diet templates
				| page.

			code
				pre.code !\!! 5
					|html
					|	head
					|		title My page: \#{pageTitle}
					|	body
					|		h1= pageTitle
					|		p This is the content of this page. The
					|			| title "\#{pageTitle}" is inserted dynamically.
					|			| We can also use loops and other D statements:
					|		block placeholder
					|		p
					|			- foreach(i, ch; pageTitle)
					|				| \#{i+1}. character: \#{ch}
					|		p.special.small This paragraph has the 'special'
					|			| and 'small' CSS classes
					|		p#footer This paragraph has the id 'footer'.
					|		#somediv
					|			| I'm a text inside the div #\#somediv
				.caption Example: Template file with dynamic code inserts and several other template features

				
		section
			h3#http-error-pages Error pages
			
			p There are two ways in which an error page is sent back to the client:
			
			ul
				li An exception is thrown from the request handler or while parsing the request. By default, a 500 "Internal Server Error" is returned. By throwing a
					a(href="api/vibe.http.server/HttpStatusException")
						code.prettyprint.lang-d HttpStatusException
					|, the status code can be customized.
				li The request handler does not write a response. In this case the server automatically returns a 404 "Not Found" error.
			
			p The
				a(href="api/vibe.http.server/HttpServerSettings")
					code.prettyprint.lang-d HttpServerSettings
				| can be used to provide a custom error page handler. If one is provided, it is called for any of the two conditions and must render an error page to the response object. If no handler is given, a simple plain-text error page is generated.			

			pre.code.prettyprint.lang-d import vibe.d
				|void error(HttpServerRequest req, HttpServerResponse res, HttpServerErrorInfo error)
				|{
				|	res.renderCompat!("error.dl",
				|		HttpServerRequest, "req",
				|		HttpServerErrorInfo, "error")
				|		(req, error);
				|}
				|
				|static this()
				|{
				|	auto settings = new HttpServerSettings;
				|	settings.errorPageHandler = toDelegate(&error);
				|
				|	auto router = new UrlRouter;
				|	// ...
				|
				|	listenHttp(settings, router);
				|}

			.caption Example: A typical setup for an error page handler

			
		section
			h3#http-authentication Authentication
			
			p Currently, the only built-in authentication method is HTTP-Basic-Auth. HTTP-Digest-Auth will follow later and higher level mechanisms such as OAuth will be provided using extension libraries.
			p The recommended practice for plugging authentication into a web application is to use the fall-through feature of the UrlRouter. If the user is properly authenticated, the
				a(href="api/vibe.http.auth.basic_auth/performBasicAuth")
					code.prettyprint.lang-d performBasicAuth
				| function will not do anything and the UrlRouter will continue to match the request to all following routes. If, however, there is no authentication or if the username/password pair is not valid, it will throw a
				a(href="api/vibe.http.server/HttpStatusException")
					code.prettyprint.lang-d HttpStatusException
				| exception which generates a 403 error page so that the user is prompted with a password dialog on the browser side. The routing stops in this case.
			
			code
				pre.prettyprint.lang-d import vibe.d;
					|
					|bool checkPassword(string user, string password)
					|{
					|	return user == "admin" && password == "secret";
					|}
					|
					|static this()
					|{
					|	auto router = new UrlRouter;
					|	// the following routes are accessible without authentication:
					|	router.get("/", staticTemplate!"index.dl");
					|	router.get("/about", staticTemplate!"about.dl");
					|   
					|	// now any request is matched and checked for authentication:
					|	router.any("*", performBasicAuth("Site Realm", toDelegate(&checkPassword)));
					|
					|	// the following routes can only be reached if authenticated:
					|	router.get("/profile", staticTemplate!"profile.dl");
					|	router.get("/internal", staticTemplate!"internal.dl");
					|
					|	// ...
					|}
				.caption Example: Using HTTP-Basic-Auth to restrict access
			

		section
			h3#http-sessions Sessions
			
			p Cookie based HTTP sessions are supported directly by the HTTP server. To be able to use them, you first have to set a
				code.prettyprint.lang-d SessionStore
				| in the
				a(href="api/vibe.http.server/HttpServerSettings")
					code.prettyprint.lang-d HttpServerSettings
				|. Sessions are then established by calling
				a(href="api/vibe.http.server/HttpServerResponse.startSession")
					code.prettyprint.lang-d HttpServerResponse.startSession
				| and stopped using
				a(href="api/vibe.http.server/HttpServerResponse.terminateSession")
					code.prettyprint.lang-d HttpServerResponse.terminateSession
				|. The returned
				a(href="api/vibe.http.session/Session")
					code.prettyprint.lang-d Session
				| object behaves as a key value store taking strings as keys and values.
			
			code
				pre.prettyprint.lang-d import vibe.d;
					|
					|void login(HttpServerRequest req, HttpServerResponse res)
					|{
					|	// todo: verify user/password here
					|
					|	auto session = res.startSession();
					|	session["username"] = req.form["username"];
					|	session["password"] = req.form["password"];
					|	res.redirect("/home");
					|}
					|
					|void logout(HttpServerRequest req, HttpServerResponse res)
					|{
					|	res.terminateSession();
					|	res.redirect("/");
					|}
					|
					|void checkLogin(HttpServerRequest req, HttpServerResponse res)
					|{
					|	// force a redirect to / for unauthenticated users
					|	if( req.session is null )
					|		res.redirect("/");
					|}
					|
					|static this()
					|{
					|	auto router = new UrlRouter;
					|	router.get("/", staticTemplate!"index.dl");
					|	router.post("/login", &login);
					|	router.post("/logout", &logout);
					|	// restrict all following routes to authenticated users:
					|	router.any("*", &checkLogin);
					|	router.get("/home", staticTemplate!"home.dl");
					|
					|	auto settings = new HttpServerSettings;
					|	settings.sessionStore = new MemorySessionStore;
					|	// ...
					|}
				.caption Example: Using a HTTP session for user authentication


		section
			h3#http-client-requests Client requests
			
			p Client request are done using the <a href="api/vibe.http.client/requestHttp"><code class="prettyprint">requestHttp()</code></a> function.

			code
				pre.prettyprint.lang-d
					|import vibe.vibe
					|
					|void main()
					|{
					|	auto res = requestHttp("http://google.com", (req){
					|			/* could e.g. add headers here before sending*/
					|		});
					|	logInfo("Response: %s", res.bodyReader.readAllUtf8());
					|}
				.caption Example: Performing a simple HTTP request

			p A connection pool is used internally in conjunction with persistent HTTP connection to reduce the number of connection establishments.

	section
		h2#db-support Database support

		section
			h3#mongo MongoDB

			p A native
				a.extern(href="http://www.mongodb.org/", target="_blank") MongoDB
				| driver is part of the distribution supporting the standard set of database operations. Data is exchanged using the
				a(href="api/vibe.data.bson#Bson")
					code.prettyprint.lang-d Bson
				| struct.

			p For an comprehensive documentation of MongoDB's operations see the
				a.extern(href="http://www.mongodb.org/display/DOCS/Manual", target="_blank") MongoDB manual
				|. The
				a(href="api/vibe.db.mongo.mongo/") API reference
				| contains the documentation for the driver.

			code
				pre.code.prettyprint.lang-d import vibe.d;
					|
					|MongoClient client;
					|
					|void test()
					|{
					|	auto coll = client.getCollection("test.collection");
					|	foreach( doc; coll.find(["name": "Peter"]) )
					|		logInfo("Found entry: %s", cast(Json)doc);
					|}
					|
					|static this()
					|{
					|	client = connectMongoDB("127.0.0.1");
					|}
				.caption Example: Finding entries in a MongoDB

		section		
			h3#redis Redis
			
			p A rudimentary client for the structured storage server
				a.extern(href="http://redis.io", target="_blank") Redis
				| is included in Vibe. Commands and operations on Redis data types are implemented as instance methods of the client. The methods are named after their corresponding Redis command documented in the
				a.extern(href="http://redis.io/commands") command reference
				|.

	section
		h2#raw-tcp Raw TCP
		
		p Low level TCP connections are handled using the
			a(href="api/vibe.core.net/TcpConnection")
				code.prettyprint.lang-d TcpConnection
			| class, which implements the
			a(href="api/vibe.stream.stream/Stream")
				code.prettyprint.lang-d Stream
			| interface. Connections can be established by either listening on a specific port for incoming connections or by actively connecting to a remote server.

		section
			h3#tcp-server Server
			
			p Listening for TCP connections is done using the
				a(href="api/vibe.core.net/listenTcp")
					code.prettyprint.lang-d listenTcp
				| function. An implementation of a very simple echo server could look like this:
				
			pre.code.prettyprint.lang-d import vibe.d;
				|
				|static this()
				|{
				|	listenTcp(7, (conn){ conn.write(conn) });
				|}

			p Calling 
				a(href="api/vibe.core.net/listenTcp")
					code.prettyprint.lang-d listenTcp
				| like this will listen on all local network devices. To listen only on a specific device, the bind address can be given as an additional parameter:
			pre.code.prettyprint.lang-d import vibe.d;
				|
				|static this()
				|{
				|	listenTcp(7, conn => conn.write(conn), "127.0.0.1");
				|}
				
			p The address can be given as an IP address string (IPv4 or IPv6 format), as an
				code.prettyprint.lang-d uint
				| for numeric IPv4 addresses or as a
				code.prettyprint.lang-d in6_addr
				| for numeric IPv6 addresses.
				
		section
			h3#tcp-client Client
			
			p Connecting to a TCP server is done with the
				a(href="api/vibe.core.net/connectTcp")
					code.prettyprint.lang-d connectTcp
				| function. The following example gets the current time using the
				a.extern(href="http://en.wikipedia.org/wiki/Daytime_Protocol", target="_blank") Daytime Protocol
				|.
			pre.code.prettyprint.lang-d import vibe.d;
				|
				|static this()
				|{
				|	auto conn = connectTcp("time-b.timefreq.bldrdoc.gov", 13);
				|	logInfo("The time is: %s", cast(string)conn.readAll());
				|}

	section
		h2#advanced Advanced topics
		
		section
			h3#dub-publishing Publishing on the DUB registry
			
			p The
				a.extern(href="http://registry.vibed.org/", target="_blank") DUB registry
				| contains packages that use the same package management as vibe.d. Many of them extend and supplement vibe.d's functionality. The packages are automatically downloaded if the corresponding entry in the "dependencies" section of the project's package.json file is present.
			
			p If you have written an extension library yourself, you can register it in the DUB registry so others can easily make use of it. For this to work, you will first have to write a proper package.json, which has to lie in the root directory of your project (the project should adhere to the structure mentioned in the <a href="#first-steps">first steps</a>). The project currently also has to be hosted on github. See <a href="http://registry.vibed.org/publish">http://registry.vibed.org/publish</a> for more information.
				
			pre.code {
				|	"name": "vibelog",
				|	"description": "A light-weight embeddable blog implementation",
				|	"homepage": "https://github.com/rejectedsoftware/vibelog",
				|	"authors": [
				|		"Sönke Ludwig"
				|	],
				|	"dependencies": {
				|	}
				|}
			.caption Example: A package.json file suitable for registration as a DUB package.
				
			p You can then register your project on
				a.extern(href="http://registry.vibed.org/", target="_blank") registry.vibed.org
				| and as soon as you then add a new
				a.extern(href="http://learn.github.com/p/tagging.html", target="_blank") git tag
				| with the name matching the current version prefixed with 'v' (v0.0.1 for the example here), it should appear there. Note that the update can take up to 30 minutes. Anyone can then add an entry similar to the following to their project to make use of the library:
				
			pre.code {
				|	...
				|	"dependencies": {
				|		"vibelog": ">=0.0.1"
				|	}
				|}
			.caption Example: Corresponding dependency to use the published DUB package.
		
		section
			h3#custom-main Custom main function
			
			p When writing a client application, maybe something like <a href="http://www.gnu.org/software/wget/">wget</a>, it may not be desirable to start an explicit event loop, but instead exit right after the work is done. Some applications might also need more control of how vibe is initialized or when the event loop is started. To support such usage scenarios, you can implement your own main() function. To be able to do this, you just have to import "vibe.vibe" instead of "vibe.d". This will tell the compiler to not use the main() function that vibe.d provides.
				
			pre.code.prettyprint.lang-d import vibe.vibe;
				|
				|int main(string[] args)
				|{
				|	processCommandLineArgs(args);
				|	return start();
				|}
			.caption Example: Simple custom main function that runs an event loop.
			
			pre.code.prettyprint.lang-d import vibe.vibe;
				|
				|int main()
				|{
				|	auto f = openFile("test.html", FileMode.CreateTrunc);
				|	f.write(download("http://google.com/"));
				|	return 0;
				|}
			.caption Example: Client application that downloads a document
		
		section
			h3#privilege-lowering Privilege lowering

			p For server applications it may be desirable to start the application as root so that it can listen on privileged ports or open system log files for writing. After these setup tasks, such applications impose a security risk because a hole in the application that allows to somehow execute commands on the server will give the attacker full access to the system. For this reason vibe supports privilege lowering, where the user id and group id of the process are changed to an unprivileged user after the setup process, right before the event loop is started.
			
			p Privilege lowering can be configured in the configuration file /etc/vibe/vibe.conf (on Windows vibe.conf must be in the application's root directory instead). The two fields "user" and "group" have to be set to the the name or numeric ID of the unprivileged user/group.
			
			pre.code
				|{
				|	"user": "www-data",
				|	"group": "www-data"
				|}
			.caption Example vibe.conf file
